#-*- coding: utf-8 -*-
# Filename: utils.py
# Description: General utility functions for the orchestrator.
# Version: 1.3.0 (Refined failure history formatting)

import json
import logging
import re
import ast # Abstract Syntax Trees - potentially useful for seed gen, but keeping simple for now
from typing import Optional, Dict, Any, List, Union

# Assuming models.py defines ProjectStructureOutput, PhasingPlanOutput
from . import config
from . import models

logger = logging.getLogger(__name__)

def safe_json_loads(text: str) -> Optional[Union[Dict[str, Any], List[Any]]]:
    """
    Safely attempts to parse a JSON string, handling potential errors
    and optional Markdown code blocks (```json ... ``` or ``` ... ```).

    Args:
        text: The string potentially containing JSON.

    Returns:
        The parsed Python object (dict or list), or None if parsing fails.
    """
    if not text:
        logger.warning("safe_json_loads called with empty or None string.")
        return None

    text = text.strip()
    json_text = text

    # Regex to find ```json ... ``` or ``` ... ``` blocks (flexible)
    # Allows optional 'json' label, case-insensitive, handles various whitespace/newlines
    # Matches curly braces {} for objects or square brackets [] for arrays.
    # Uses non-greedy matching for content .*?
    match = re.search(r'```?(?:json)?\s*(\{.*?\}|\[.*?\])\s*```?', text, re.IGNORECASE | re.DOTALL)


    if match:
        json_text = match.group(1).strip()
        logger.debug("Extracted JSON content from Markdown code block (using ```).")
    else:
        # If no markdown block, check if the whole string *looks like* JSON.
        if not ((text.startswith('{') and text.endswith('}')) or \
                (text.startswith('[') and text.endswith(']'))):
            logger.warning("Response does not appear to be enclosed in JSON Markdown block or be a plain JSON object/array. Parsing attempt may fail.")
            # Proceed to attempt parsing the whole text anyway as a fallback.

    try:
        # Attempt to parse the extracted or original text
        parsed_data = json.loads(json_text)
        # Ensure it's a dict or list, as expected by most callers
        if isinstance(parsed_data, (dict, list)):
             return parsed_data
        else:
             logger.error(f"Parsed JSON is not a dictionary or list, but type '{type(parsed_data).__name__}'. Value: {parsed_data}")
             return None
    except json.JSONDecodeError as e:
        logger.error(f"JSON decode failed: {e}")
        # Provide context around the error position for easier debugging
        context_len = 100 # Characters before/after error position
        start_index = max(0, e.pos - context_len)
        end_index = min(len(json_text), e.pos + context_len)
        error_context = json_text[start_index:end_index]
        # Calculate pointer position relative to the start of the context window
        pointer_offset = e.pos - start_index
        # Ensure pointer doesn't go out of bounds for the context window
        pointer_offset = max(0, min(pointer_offset, len(error_context) -1 if len(error_context) > 0 else 0))
        pointer = (" " * pointer_offset + "^")

        logger.debug(f"Problematic JSON text near pos {e.pos} (within context window):\n...{error_context}...\n   {pointer}")
        # Log a larger portion of the text that failed, truncated for sanity
        logger.debug(f"Full text attempted parse (first 1000 chars):\n{json_text[:1000]}...")
        return None
    except Exception as e:
        # Catch other potential errors during loading (though less common)
        logger.error(f"Unexpected error during JSON loading: {e}", exc_info=True)
        return None


def generate_continuity_seed(design: Optional[models.ProjectStructureOutput],
                               final_plan: Optional[models.PhasingPlanOutput]) -> str:
    """
    Generates a continuity seed string based on the project design and plan.
    Focuses on high-level architecture and shared components.

    Args:
        design: The parsed ProjectStructureOutput object.
        final_plan: The parsed PhasingPlanOutput object (used for context).

    Returns:
        A concise string summarizing key context for the build phase, truncated
        to `config.CONTINUITY_SEED_MAX_LEN`, or "N/A".
    """
    # Use the seed generated by the planning phase if available and valid
    if final_plan and final_plan.initial_continuity_seed:
        seed = final_plan.initial_continuity_seed.strip()
        if seed.lower() not in ["", "n/a", "none", "null"]:
             if len(seed) > config.CONTINUITY_SEED_MAX_LEN:
                 truncated_seed = seed[:config.CONTINUITY_SEED_MAX_LEN - 3] + "..."
                 logger.debug(f"Using truncated planning-generated continuity seed ({len(truncated_seed)} chars).")
                 return truncated_seed
             else:
                 logger.debug(f"Using planning-generated continuity seed ({len(seed)} chars).")
                 return seed
        else:
            logger.debug("Planning phase generated null/empty seed. Generating fallback seed.")
            # Fall through to generate fallback if plan seed was null/empty

    # Fallback generation if no valid seed from planning or no plan data
    if not design:
        return "N/A (Design data unavailable for fallback seed generation)"

    seed_parts = []

    # 1. Include architecture summary from design
    if design.design_summary:
         summary = design.design_summary.strip()
         sentences = re.split(r'(?<=[.!?])\s+', summary) # Split into sentences
         summary_short = ". ".join(sentences[:2]) # Take max 2 sentences
         if len(summary_short) < len(summary): summary_short += "."
         seed_parts.append(f"Arch Summary: {summary_short}")

    # 2. List key shared interfaces/models if they exist
    if design.shared_interfaces:
        shared_names = list(design.shared_interfaces.keys())
        if shared_names:
            seed_parts.append(f"Key Shared Interfaces/Models: {', '.join(shared_names)}.")

    # 3. Mention key file categories or purposes from design (first few files)
    if design.file_structure:
        purposes = []
        max_files_for_seed = 4
        for i, file_def in enumerate(design.file_structure):
             if i >= max_files_for_seed: break
             purpose = f"'{file_def.path}' ({file_def.description or 'No description'})"
             purposes.append(purpose)
        if purposes:
             seed_parts.append(f"Initial Files Focus: {'; '.join(purposes)}.")

    # 4. Optionally reference the plan structure (e.g., number of phases)
    if final_plan and final_plan.final_phasing_plan:
         seed_parts.append(f"Overall Plan: {len(final_plan.final_phasing_plan)} phases.")


    if not seed_parts:
        return "N/A (No specific continuity points identified from design/plan for fallback seed)"

    # Combine parts into a single string
    seed = " | ".join(seed_parts) # Use a separator

    # Truncate if exceeds max length
    if len(seed) > config.CONTINUITY_SEED_MAX_LEN:
        truncated_seed = seed[:config.CONTINUITY_SEED_MAX_LEN - 3] + "..."
        logger.debug(f"Generated fallback continuity seed truncated from {len(seed)} to {len(truncated_seed)} chars.")
        return truncated_seed
    else:
        logger.debug(f"Generated fallback continuity seed ({len(seed)} chars): {seed}")
        return seed


def format_failure_history(history_list: List[str], context: str = "General") -> str:
    """
    Formats a list of failure strings (from test output or LLM errors)
    for inclusion in debug prompts, showing recent failures first and adding context.

    Args:
        history_list: List of strings, where each string describes a failure reason.
        context: String indicating the context (e.g., "Generation/Validation", "Test/Gen").

    Returns:
        A formatted markdown string, or "N/A" if the history is empty.
    """
    if not history_list:
        return "N/A" # Explicitly state no history available

    formatted = f"\n## History of Failures ({context}, Most Recent First):\n"
    # Iterate in reverse to show most recent failures first
    for idx, failure_output in enumerate(reversed(history_list)):
        entry_num = len(history_list) - idx # Calculate original entry number
        # Limit the length of each individual failure message
        max_hist_item_len = 800 # Truncate individual history items if too long
        failure_text = failure_output.strip()

        if len(failure_text) > max_hist_item_len:
            failure_text = failure_text[:max_hist_item_len] + "\n... [Truncated Failure Message]"

        # Identify the type of failure if possible from common prefixes used in orchestrator.py
        failure_type = "Unknown"
        if failure_text.startswith("[BUILD_C") or failure_text.startswith("[GEN_DEBUG_C"):
            failure_type = "Generation/Validation"
        elif failure_text.startswith("[TEST_DEBUG_C"):
            failure_type = "Test Debug LLM"
        elif failure_text.startswith("Phase-Level Test Failure"):
             failure_type = "Test Execution"
        elif failure_text.startswith("LLM/Validation Error"): # Handle specific case from orchestrator
             failure_type = "Generation/Validation"


        # Add header for each failure entry
        formatted += f"\n### Failure Entry {entry_num} (Type: {failure_type}):\n"
        # Use a markdown code block for the failure details
        # Indent the failure output within the markdown block for readability
        indented_failure_text = "\n".join(["  " + line for line in failure_text.split("\n")])
        formatted += f"```text\n{indented_failure_text}\n```\n" # Use ``` as requested

    return formatted
